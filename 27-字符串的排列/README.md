## 题目描述
输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

## 解题思路
### 方法一：递归
1、无重复值的情况<br>
（1）固定第一个字符，递归取得首位后面的各种字符串组合；<br>
（2）再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合；（递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串）<br>

2、有重复值<br>
（1）由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。<br>
（2）例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。<br>
（3）但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。<br>
（4）由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。<br>
### 方法二：非递归
一个全排列可看做一个字符串，字符串可有前缀、后缀。生成给定全排列的下一个排列，所谓一个的下一个就是这一个与下一个之间没有其他的。这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。

[例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321，从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。

[例]如何得到346987521的下一个

1. 从尾部往前找第一个P(i-1) < P(i)的位置<br>
   3 4 6 <- 9 <- 8 <- 7 <- 5 <- 2 <- 1<br>
   最终找到6是第一个变小的数字，记录下6的位置i-1<br>
2. 从i位置往后找到最后一个大于6的数<br>
   3 4 6 -> 9 -> 8 -> 7 5 2 1<br>
   最终找到7的位置，记录位置为m<br>
3. 交换位置i-1和m的值<br>
   3 4 7 9 8 6 5 2 1<br>
   4，倒序i位置后的所有数据<br>
   3 4 7 1 2 5 6 8 9<br>
   则347125689为346987521的下一个排列
